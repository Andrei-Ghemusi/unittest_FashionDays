from unittest import TestCase
from selenium.webdriver.common.by import By
from selenium.webdriver.remote.webelement import WebElement
from webdriver_manager.chrome import ChromeDriverManager
from selenium import webdriver
import subprocess
import os
from main.utility_methods import TestUtils


class NonFunctionalTestsMainPage(TestCase):
    PERFORMANCE: tuple[str, str] = (By.XPATH, '//*[@id="performance"]/div[1]/div[1]/div[1]/a/div[2]')
    ACCESSIBILITY: tuple[str, str] = (By.XPATH, '//*[@id="accessibility"]/div[1]/div[1]/a/div[2]')
    BEST_PRACTICES: tuple[str, str] = (By.XPATH, '//*[@id="best-practices"]/div[1]/div[1]/a/div[2]')
    SEO: tuple[str, str] = (By.XPATH, '//*[@id="seo"]/div[1]/div[1]/a/div[2]')

    @classmethod
    def setUpClass(cls):
        cls.generate_lighthouse_report()

    @classmethod
    def generate_lighthouse_report(cls):
        lighthouse_command: str = "lighthouse --throttling.cpuSlowdownMultiplier=3 https://www.fashiondays.ro/ --output=html --quiet --output-path=reports\\lighthouse_report.html"
        subprocess.run(lighthouse_command, shell=True)
        # here we first run command to run lighthouse and to also generate a html report
        # I used the 'setUpClass' class method to have my lighthouse report generated only once and not for every test

    def setUp(self):
        self.chrome = webdriver.Chrome(executable_path=ChromeDriverManager().install())
        self.chrome.maximize_window()
        self.get_html_report()
        # here we call the method to open the html report for every test

    def tearDown(self):
        self.chrome.quit()


    # this method is made to open/get the html report generated by lighthouse
    def get_html_report(self):
        script_dir = os.path.dirname(os.path.abspath(__file__))
        # here we get the absolute path of the directory
        report_path = os.path.join(script_dir, '..', 'main', 'reports', 'lighthouse_report.html')
        # here we make the relative path
        report_url: str = ('file:///' + report_path.replace('//', '/'))
        # we replace the single slash with doubles
        self.chrome.get(report_url)
        # now we open the html report


    """
    !!! REMINDER !!!
    For demonstration purposes I set the values of the expected scores to 1 as to not get any failed tests
    In real life scenarios the expected number will, of course, change.
    """

    # This method is made to check if the actual score is equal or greater than the expected one
    def assert_score(self, element, expected_score):
        full_element: WebElement = self.chrome.find_element(*element)
        actual_score: int = int(full_element.text)
        self.assertGreaterEqual(actual_score, expected_score, f'ERROR: was expected the score to be at least {expected_score}, but got {actual_score}')
        # when called this method will take 2 arguments, our element - which gets parsed to integer to the actual score value - and the second element which is the expected score


    # This method checks the performance score
    def test_performance_score(self):
        TestUtils.move_to_element(self.chrome, element=self.PERFORMANCE)
        # here we called the scroll_to_element method to scroll to the performance score element
        self.assert_score(element=self.PERFORMANCE, expected_score=1)
        # then we call the assert_score method to check if the actual score is greater or equal to the expected one

    # This method checks the accessibility score
    def test_accessibility_score(self):
        TestUtils.move_to_element(self.chrome, element=self.ACCESSIBILITY)
        self.assert_score(element=self.ACCESSIBILITY, expected_score=1)


    # this method checks the best practices score
    def test_best_practices_score(self):
        TestUtils.move_to_element(self.chrome, element=self.BEST_PRACTICES)
        self.assert_score(element=self.BEST_PRACTICES, expected_score=1)


    # this method checks the seo score
    def test_seo_score(self):
        TestUtils.move_to_element(self.chrome, element=self.SEO)
        self.assert_score(element=self.SEO, expected_score=1)